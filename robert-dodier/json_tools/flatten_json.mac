/* flatten_json.mac -- flatten blob("foo" = blob("bar" = 123)) to foo.bar = 123
 *
 * copyright 2020 by Robert Dodier
 * I release this work under terms of the GNU GPL.
 */

flatten_json (e, prefix_tags) :=
  if listp(e)
    then flatten_json_list (e, prefix_tags)
  elseif equationp(e)
    then flatten_json_equation (e, prefix_tags)
  elseif blobp(e)
    then flatten_json_blob (e, prefix_tags)
  else
    apply (".", prefix_tags) = e;

flatten_json_list (l, prefix_tags) :=
  if some (blobp, l)
    then flatten_json_list_of_blobs (l, prefix_tags)
    else flatten_json_list_of_nonblobs (l, prefix_tags);

flatten_json_list_of_blobs (l, prefix_tags) :=
  block ([leading_tags: rest (prefix_tags, -1),
          trailing_tag: last (prefix_tags),
          revised_tags,
          kk: gensym ()],
         revised_tags: endcons (trailing_tag(kk), leading_tags),
         makelist (flatten_json (l[k], subst (kk = k, revised_tags)), k, 1, length(l)));

/* assume that l is a list of numbers;
 * might want to verify that and handle other cases
 */
flatten_json_list_of_nonblobs (l, prefix_tags) :=
  block ([nrows, ncols],
         [nrows, ncols]: if listp(l[1])
                           then [length(l), length(l[1])]
                           else [1, length(l)],
         apply (".", prefix_tags) = transpose (reshape (flatten (l), ncols, nrows)));

equationp (e) := not atom(e) and op(e) = "=";

flatten_json_equation (e, prefix_tags) := flatten_json (rhs(e), endcons (parse_string (lhs(e)), prefix_tags));

blobp (e) := not atom(e) and op(e) = 'blob;

flatten_json_blob (b, prefix_tags) := maplist (lambda ([e], flatten_json (e, prefix_tags)), b);
