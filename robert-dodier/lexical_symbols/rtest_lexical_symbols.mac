/* maxima-discuss 2014-04-19: "How to make buildq evaluate its first argument - please help"

(%i1) gen_rhs(Ex,Vars)::= block([n:length(Ex),m:length(Vars)],
    Exs:subst(makelist(Vars[i]=y[i,1],i,m),Ex),print(Exs),
    MList:ev(makelist(makelist(Exs[i]),i,m)),print(MList),
    buildq([MList],lambda([t,y],matrix(splice(MList)))))$

(%i2) george : gen_rhs([sin(a+b),cos(a*b)],[a,b])$
[sin(y[2,1]+y[1,1]),cos(y[1,1]*y[2,1])]
[[sin(y[2,1]+y[1,1])],[cos(y[1,1]*y[2,1])]]

(%i3) george(5,z);
(%o3) matrix([sin(z[2,1]+z[1,1])],[cos(z[1,1]*z[2,1])])

(%i4) y[2,7] : 42$

(%i5) george(5,z);
(%o5) matrix([sin(y[2,1]+y[1,1])],[cos(y[1,1]*y[2,1])])
 */

(kill(y, z),
 fred: lambda([t,y],matrix([sin(y[2,1]+y[1,1])],[cos(y[1,1]*y[2,1])])),
 fred(5, z));
matrix([sin(z[2,1]+z[1,1])],[cos(z[1,1]*z[2,1])]);

(y[2,7]: 42,
 fred(5, z));
matrix([sin(z[2,1]+z[1,1])],[cos(z[1,1]*z[2,1])]);

(kill(y, z),
 gen_rhs(Ex,Vars)::=
   block([n:length(Ex), m:length(Vars), y],
         Exs:subst(makelist(Vars[i]=y[i,1],i,m),Ex),
         MList:ev(makelist(makelist(Exs[i]),i,m)),
         /* Call apply here to ensure that y in the lambda argument list
          * is the same y as in MList.
          */
         apply (lambda, [[t, y], apply (matrix, MList)])),
 george : gen_rhs([sin(a+b),cos(a*b)],[a,b]),
 string(george));
"lambda([t,y],matrix([sin(y[2,1]+y[1,1])],[cos(y[1,1]*y[2,1])]))";

george(5, z);
matrix([sin(z[2,1]+z[1,1])],[cos(z[1,1]*z[2,1])]);

(y[2,7]: 42,
 george(5, z));
matrix([sin(z[2,1]+z[1,1])],[cos(z[1,1]*z[2,1])]);

/* examples from blex.lisp
;; blex ([n:100], f(x) := n : n + x, g() := display(n));
;; blex ([f], f(x) := 2*x);
;; blex ([a], h(x) := a[x] : 1, i() := arrayinfo(a));
 */

block ([n: 100], f(x) := n: n + x, g() := ldisplay(n), 0);
0;

f(99);
199;

n;
n;

string (?meval (g()));
"[n = 199]";

block ([f], f(x) := 2*x, f1(x) := f(x), 0);
0;

f(99);
298;

f1(99);
198;

block ([a], h(x) := a[x]: 1, i() := arrayinfo(a), l() := listarray(a), 0);
0;

[h(17), h(29), h(1729)];
[1, 1, 1];

(a[11]: 2,
 a[13]: 2,
 a[17]: 2);
2;

arrayinfo(a);
[hashed, 1, [11], [13], [17]];

listarray(a);
[2, 2, 2];

i();
[hashed, 1, [17], [29], [1729]];

l();
[1, 1, 1];

/* maxima-discuss 2014-08-01: "lexical scope and more"

block([?mplus:foo],?mplus(a,a))  -->  2*a
block([ gg:foo],    gg(a,a))     -->  foo(a,a)
 */

block ([?mplus: foo], ?mplus(a, a));
foo(a, a);

block ([gg: foo], gg(a, a));
foo(a, a);

/* maxima-discuss 2014-08-09: "declared constants cannot be formal parameters"

f(x):=block([n], declare(n,constant)  g(r):=  something-with-n... );
is there a way to preserve this declaration if someone
subsequent does, say,  kill(n);
 */

block ([n], declare (n, constant), g() := constantp (n), 0);
0;

constantp (n);
false;

g();
true;

(kill(n),
 g());
true;

(kill(props),
 g());
false;

/* maxima-discuss 2014-08-14: "Allow f(x)(y)"

g(x) := subst(x, 'x, lambda([y], x + y))$      << simulated lexical scope
g(4) => lambda([y],y+4)
g(4)(5) => 9
 */

/* this already works w/ dynamic scope; include this to ensure it doesn't get messed up */
(g(x) := subst(x, 'x, lambda([y], x + y)), string(%%))$
"g(x):=subst(x,'x,lambda([y],x+y))";

string(g(4));
"lambda([y],y+4)";

g(4)(5);
9;

/* reimplement w/ lexical scope */
(g(x) := lambda([y], x + y), string(%%))$
"lambda([y],y+4)";

string(g(4));
"closure([x:4],lambda([y],x+y))";

g(4)(5);
9;

/* maxima-discuss 2014-09-07: "Define derivative of discontinue function"

Roberts (ingenious) tellsimpafter solution (http://stackoverflow.com/questi=
ons/24892016/maxima-differentiating-a-piecewise-function/25233479#25233479)=
 gives:

    (%i4) diff(if x^2 < 1 then x^3 else x,x);
    (%o4) if x^2<1 then 3*x^2 else 1

Not OK:

    (%i5) diff(if aa^2 < 1 then aa^3 else aa,aa);
    (%o5) if (aa^2<1)^2<1 then 3*(aa^2<1)^2 else 1

 */
/* maxima-discuss 2014-09-06: "Define derivative of discontinue function"

PS. The following is copied from my answer to this question
on Stackoverflow:
http://stackoverflow.com/questions/24892016/maxima-differentiating-a-piecewise-function/25233479#25233479

Here's a different approach using a simplification rule for "if"
expressions. The unsolved part here is to detect discontinuities and
generate delta functions for those locations. If you want to ignore
those, you can define FOO to return 0. Note that I didn't attempt to
implement the function discontinuities; that part is unsolved here.
I can give it a try if there is interest.

(%i1) display2d : false $
(%i2) matchdeclare ([aa, bb, cc], all, xx, symbolp) $
(%i3) 'diff (if aa then bb else cc, xx) $
(%i4) tellsimpafter (''%, apply ("if", [aa, diff (bb, xx), true, diff (cc, xx)]) + FOO (aa, bb, cc, xx)) $
(%i5) FOO (a, b, c, x) := 'lsum ((ev (c, x = d) - ev (b, x = d)) * delta (d, x), d, discontinuities (a, x)) $
(%i6) diff (if x > 0 then x^2 else x^3, x);
(%o6) (if x > 0 then 2*x else 3*x^2)+'lsum((d^3-d^2)*delta(d,x),d,
                                           discontinuities(x > 0,x))
 */

/* maxima-discuss 2014-11-10: "question on poltting absolut values"

   - What about lambda-bindings? Can assume(x>0) affect all functions with
   x as a formal? In our current system, lambda([x]...) does *not* create a
   new variable: assume(x>0)$ lambda([x],is(x>0)) => true. In principle, this
   should really be a different x.
 */

/* maxima-discuss 2014-12-22: "Unexpected behavior (no global/local decoupling) when passing a function name as a parameter to another function"

    kill(all)$
    fun(h):=diff(h(x,y),x)+diff(h(x,y),y)$
    h0(x,y):=sin(x)*cos(y)$
    fun(h0);

correctly returns:

    cos(x)*cos(y)-sin(x)*sin(y)

However, by interposing a global definition of "h":

    kill(all)$
    fun(h):=diff(h(x,y),x)+diff(h(x,y),y)$
    h0(x,y):=sin(x)*cos(y)$
    h(x,y):=x*y$ /*<<<<<<<<<<<<<<<<<<*/
    fun(h0);

we obtain:

    y+x

which points out that a global definition of "h" overrides the parameter passed to the function.

Such behavior is inconsistent with the case of a non-functional parameter, i.e.

         kill(all)$
    fun(h):=diff(h,x)+diff(h,y)$
    h0:sin(x)*cos(y)$
    h:x*y$ /*<<<<<<<<<<<<<<<<<<*/
    fun(h0);

which returns:

    cos(x)*cos(y)-sin(x)*sin(y)
 */

/* maxima-discuss 2015-06-03: "Apply function under the summation sign"

expr:'sum(x**i,i,1,3);
L(x):= block(
    g(y):=y**2,
    if operatorp(x,nounify(sum)) then block(
        summand: args(x)[1],
        apply(sum,subst(g(summand),summand,args(x)))
        ));

L(expr);
=> 'sum(x^i,i,1,3))^6+('sum(x^i,i,1,3))^4+('sum(x^i,i,1,3))^2

If I call apply(sum,subst(g(summand),summand,args(x))) outside of the
function it works as expected.
 */

/* mailing lit 2015-11-18: "Sublist"

f(k) := mod(k,mm)>0 $
mm:5 $
sublist(ll,f) $
 */

/* maxima-discuss 2015-11-25: "preventing names of algebraic symbols from conflicting with local variables?"

Z : [k,k];
f(A):=sum(A[k],k,1,2);
f(Z);

[...] he expects the result of the third line to be 2*k, when in fact he gets 3.
 */

/* maxima-discuss 2016-02-28: "Lambda functions and dynamic scoping"

    K(b,a,k) :=  block([p,q,p1:1,p2:0,q1:0,q2:1],
      for n:1 thru k do (
        p:bfloat(a(n)*p2+b(n)*p1),
        q:bfloat(a(n)*q2+b(n)*q1),
        p1:p2, p2:p, q1:q2, q2:q), p/q);

For instance, Brouncker's continued fraction for 4/pi would be

  1 + K( lambda([n], (2*n-1)^2), lambda([n], 2), 512);

[...] Yesterday, I got in trouble because I had to compute something as:

  f(k, x) := K( lambda([n], ... stuff with k, n, x ... etc.
 */

/* maxima-discuss 2016-03-16: "Maxima function changes behavior depending on the NAME of its parameter"

f(cos,x) :=  cos(x);

f(sin,x);

Should that compute sin(x)?

what about  f(lambda([x],x) ,cos(x))?
 */

/* maxima-discuss 2016-03-15: "Maxima function changes behavior depending on the NAME of its parameter"

The function call does not give the desired result, although it should. And the strange things are:

-          Changing the name of the parameter of function mmetric from g to anything else, e.g. k, will make the
function call give the correct result.

-          Alternatively, deleting code block 3 will also make the program give the correct result, so does a "kill (g)"
prior to the function call.

-          Alternatively, changing in code block 3 the indices a,b,c to 1,2,3 will also make the function call give the
correct result.



One would expect that the local parameter g is independent of the global variables g[a],g[b],g[c]. But the contrary
seems to be the case. There is some strange interdependency. Does anyone have an explanation? Is this a bug, or is it a
situation one should avoid, because it causes these side effects? What is the general issue behind that?





/* 1. Location vector R (column vector) in terms of cylindrical coordinates: */

R: covect([r*cos(phi),r*sin(phi),z]);



/* 2. Compute tangent vectors and assign them to h[1 .. ,2 .. ,3]: */

h[1]: diff(R,r);

h[2]: diff(R,phi);

h[3]: diff(R,z);



/* 3. Also assign the results to g[a .. ,b .. ,c]: */

g[a]: h[1];

g[b]: h[2];

g[c]: h[3];



/* 4.  */

arrayinfo(g);

arrayinfo(h);



/* 5. Define function to compute the metric */

mmetric(g) := block([a,b,dim,gij],

    dim: length(g[1]),

    /* print intermediate result */
    print("dim = ",dim),

    gij: zeromatrix(dim,dim),

    for a: 1 thru dim do

        for b:1 thru dim do

            gij[a,b]: g[a].g[b],

    trigsimp(gij)

)$



/* 6.  */

length(h[1]);



/* 7. Call function mmetric with argument h */

h[ij]: mmetric(h);
 */

/* maxima-discuss 2017-03-17: "Functions as parameters to lambda"

  square(f) := lambda([x],(f(x))^2);
  g:square(sin);
  g(0.1);

but the result is f^2(0.1) and not (sin(0.1))^2.
 */

/* maxima-discuss 2017-03-17: "Functions as parameters to lambda"

(%i3)   square(f) := buildq([f], lambda([x],(f(x))^2));
  g:square(sin);
  g(0.1);

(%o1) square(f):=buildq([f],lambda([x],f(x)^2))
(g)lambda([x],sin(x)^2)
(%o3) 0.009966711079379185
 */

/* maxima-discuss 2017-03-18: "Functions as parameters to lambda"

h: lambda ([b], h2:lambda ([a], a*b), h2(2));
h(3) ->  6

g: lambda ([b], g2:lambda ([a], a*b), g2);
(g(3))(2) -> 2 b
 */

/* maxima-discuss 2017-08-27: "Bound variables in lambdas only sometimes shadow globals?"

(%i1) a(x) := x;
(%o1)                              a(x) := x

(%i2) b : lambda([x], x);
(%o2)                           lambda([x], x)

(%i3) lambda([a], a())(lambda([], "foo")); /* expecting "foo" */

Too few arguments supplied to a(x); found: []
#0: lambda([a],a())(a=lambda([],"foo"))
 -- an error. To debug this try: debugmode(true);

(%i4) lambda([a], a("bar"))(lambda([], "foo")); /* expecting error */
(%o4)                                 bar
 */

/* maxima-discuss 2017-08-28: "Bound variables in lambdas only sometimes shadow globals?"

a:23$
f(a) := g()$
g():= print(a)$

With lexical binding, f(7) prints 23, the global value.

With dynamic binding, f(7) prints 7.

And with dynamic binding, ( f(7), g() )  prints 7 then 23, not 7 then 7,
 */

/* maxima-discuss 2017-11-03: "Free-variable capture in Maxima, was: Evaluate derivative at a point with ev"

    x:0$
    f(x):=g(47)$
    g(y) := x$       <<< x here is a "free" variable because there is no
visible surrounding declaration

then

      f(23) => 23  because when g(47) is called, x is bound to 23

but if g is called from the top level, it returns a different value:

      g(99) => 0

That is, the value of g(99) may depend on who called it.

This is different from most languages which have what is called "lexical"
or "static" scope. In lexical scope, the "x" in g() is looked up in the
global scope, not in the calling function's (f) scope. In lexical scope,
both f(23) and g() would return 0.
 */

/* maxima-discuss 2018-09-07: "\"lambda\" should be renamed to something else"

(%i1) lambda([f], lambda([x], [f, x]))(g)(y);
(%o1)                               [f, y]
 */

/* maxima-discuss 2018-09-08: "\"lambda\" should be renamed to something else"

f: block([private:0],lambda([],private:private+1))

In true lexical scope, this is a closure with the following behavior:

      [f(), f(), f()] => [1,2,3]

And of course it doesn't matter if there are other variables named
"private":

      block( [private:100], [f(),private:200,f()]) => [4,200,5]
 */

/* maxima-discuss 2019-03-24: "Questions about compiling"

Point 1:

       f():= block([innerf],  innerf():=23, myf())$
       f() => 23, as expected.
       innerf() => 23 !!! Function definitions are global.

       kill(f,innerf)$
       f():= block([innerf], local(innerf), innerf():=23, innerf())$
       f() => 23, as expected.
       innerf() => innerf()    <<< OK, myf is now local to f

Point 2:

       g() := block( [innerf, var: 23], local(innerf),
                      innerf():=var,
                      block([var: 56], innerf()))$
       g() => 56    <<< follows from dynamic scope rules

*/

/* maxima-discuss 2019-03-24: "Questions about compiling"

func() := print(3)$
ff():=block([func],func:lambda([],print(88)), func())$
ff() => 3

so, surprisingly perhaps, you still need to use local:

func() := print(3)$
ff():=block([func],local(func), func:lambda([],print(88)), func())$
ff() => 3

or somehow force the value rather than the function value to be used in
this charmingly (?) obscure way:

func() := print(3)$
ff():=block([func], func:lambda([],print(88)), (+func)()) ;
ff() => 88
 */

/* maxima-discuss 2019-05-15: "Scope error with sum"

    f(x) := sum(i*x, i, 1, 5);         (with f(i) = 55 )
will look like an error.
 */

/* maxima-discuss 2019-05-25: "Question about defmatch"

find_sin(z):=block([kk:[]], apply1(z,push_on_kk), kk);

push_on_kk(r):= if not(mapatom(r)) and (part(r,0)=sin) then push(r,kk);

example

hh:sin(w)+4*sin(mm);
find_sin(hh);   returns      [sin(w),sin(mm)]
 */

/* maxima-discuss 2019-05-28: "Advantages of dynamic scoping (was Question about defmatch)"

(%i1)      mod1(value,modulus):=mod(value-1,modulus)+1$
(%i2)      mod1(0,8);
warning: assigning 8, a non-prime, to 'modulus'
(%o2)     8
 */

/* maxima-discuss 2019-05-28: "Advantages of dynamic scoping (was Question about defmatch)"

bar():=  parse_string("x");

bar()-x
              is that 0?

what about
bar():=block([x:45],parse_string("x"));
 */

/* maxima-discuss 2019-09-28: "Symbol collision via MEVAL in integration, was: Problem with fourier"

> load("fourie")$
> fourier(f(t+(t1+T/2)),t,T)$
> fourier(g(t+(t1+T/2)),t,T)$
>
> The fourier series computed for f is very different to that computed for g.
> That for g is what I would have expected.

Renaming f to f% throughout fourie.mac causes fourier to give the
expected for fourier(f(t+(t1+T/2)),t,T). I've pushed commit 4650d2d to
implement that.
 */

/* maxima-discuss 2019-11-06: "Interference of a forrmal parameter of a function and a global variable of the same name"

Apply2Part(f, [subexpr]):=block(

    local(f, subexpr),

    apply(substpart, cons(apply(f, [apply(part, subexpr)]), subexpr))

)$



Example:



expr: u=m*r^2*d+m*s^2*g+m*t^2*h;    =>    u=h*m*t^2+g*m*s^2+d*m*r^2



Apply2Part(factor, expr, 2, [1,2]);    =>    u=m*(h*t^2+g*s^2)+d*m*r^2



expr1: u=m*r^2*f+m*s^2*g+m*t^2*h;    =>    u=h*m*t^2+g*m*s^2+f*m*r^2



Apply2Part(factor, expr1, 2, [1,2]);    =>    u=m*(h*t^2+g*s^2)+factor*m*r^2
 */

/* maxima-discuss 2019-11-20: "Strange behavior of a simple function"

foo(x,y) := x[1] + y[2]$

Now consider a call like foo(a,b). This will give:

a[1]+b[2]

as expected. However, now consider foo(y,a). This will give:

a[1] + a[2]

The correct answer should have been:

y[1] + a[2]

Worse, calling foo(y,x) will make Maxima hang.
 */

/* maxima-discuss 2019-11-19: "general proposal to implement lexical scope + path to Maxima 6.0 version"

A couple of possibly confusing cases:

     f(x):='x returns a symbol which looks like x, but isn't x.

     f(ex,x):=diff(ex,x) works fine
     f(ex,x):=diff(ex,'x) might not work as expected -- if the user expects 'x to be the same ex as in the input expression

 */

/* maxima-discuss 2019-11-20: "Re: [Maxima-discuss] general proposal to implement lexical"


(%i4) bob(a,b,c,x) := block([p : [a,b], q : [c]],hypergeometric(p,q,x));
warning: The first two arguments to 'hypergeometric' must be lists.

But function bob seems to work OK

(%i5) bob(2,3,1/2,x);
(%o5) hypergeometric([2,3],[1/2],x)

 */


/* maxima-discuss 2019-11-19: "concepts vs implementation, was: general proposal to implement lexical"


matchdeclare(p1, true);
defrule(r1,m(p1,p1), double(p1));
apply1(m(3,3),r1)  ;

defrule(r2,k(p1),p1(k));
sin:cos;
apply1(k(sin),r2);

[...]

/*Easy. */
integrate(sin(x),x);
sum(f(i),i,n,n+1);
sum(n,i,n,n+1);  /* 2*n */
product(n,i,n,n+1);
block([j:0], for j:1 thru 10 do nothing, j);
block([j:10], while j>0 do j:j-1,j);
block([sin:cos], [sin(x),apply(sin,[x])]);


/* more challenging */
block([h:43,ans:[]],kill(f),
  push([1,f(1)],ans),
  f(e):=g(e),
  push([2,f(2)],ans),
  f(r):=block([m:h+r],m),
  push([3,f(3)],ans),
  f(r):=block([h],h+r),
  push([4,f(4)],ans),
  f(r):=block([],h+r),
  push([5,f(5)],ans),
  f(r):=(f(s):=g(r),1776),
  push([6,f(6)],ans),
  push([7,f(7)],ans),

  reverse(ans));


test3(e):=block([x],integrate(x^e,x))$
x^2/2-test3(1);

w(z):=block([numer:true],sin(z));

inv(f,x,y):= solve(f(x)=y,x);
kill(f);
inv(atan,x,y);



gg(f,g):=gradef(f(x),g(x));

gg(foo,bar)   /* fails, define gradient for f, not foo */
 */

